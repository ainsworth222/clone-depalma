'''
Bifd Cipher, p. 14
'''

'''
Pre:  key_in is the key entered by the user 
Post: returns key used in encrypt and decrypt  
'''
def make_key(key_in):
    #create the alphabet as a string, excluding 'J'
    alph = [chr(i) for i in range(ord('A'), ord('Z') + 1, 1) if chr(i) != 'J']

    #extract characters from alphabet not in key to a list
    key_lst = [ch for ch in alph if ch not in key_in]

    #prepend key_in to the string version of key_lst
    key = key_in + ''.join(key_lst)

    return key

'''
Pre: plaintext contains only UC alpha characters. key is the key generated in make_key  
Post: ciphertext is returned using the Bicd cipher
'''
def encrypt(plaintext,key):

  #Produce a list of tuples that are indices into the virtual 5X5 array 
  #created by distributing the key column-wise. This produces, for example, 
  #the tuples in the middle of p. 14, read vertically: [(3,1),(0,0),...,(0,4) 
  tuple_lst = [(key.index(ch)//5, key.index(ch)%5) for ch in plaintext]

  #Transpose tuple_lst: create a list from the 0th elements in the tuples. Append
  #to it a list of the 1st elements in the tuples. This produces,for example, a list version
  #of the string on p.14: [3,0,0,...,4]    
  transpose_lst = ([x[0] for x in tuple_lst] + [x[1] for x in tuple_lst])

  #tupleize transpose_lst  
  pair_lst = [(transpose_lst[2*i],transpose_lst[2*i + 1]) for i in range(len(plaintext))]  

  #Reverse the procedure that produces tuple_lst, transforming each tuple into an index
  #into the key 
  idx_lst = [5*pair[0] + pair[1] for pair in pair_lst]

  #Retrieve the character in the key corresponding each index in idx_lst   
  ciphertext_lst = [key[idx] for idx in idx_lst]

  #Transfrom the list to a string
  ciphertext = ''.join(ciphertext_lst)

  return ciphertext 

'''
Pre: ciphertext is the text the text generated by encrypt.  key is the key geneated by
     make_key 
Post:returns plaintext 
'''
def decrypt(ciphertext,key):
  #produce a list of tuples that are indices into a virtual 5 X 5 array.   
  tuple_lst = [(key.index(ch)//5, key.index(ch)%5) for ch in ciphertext]

  #detuplize
  indices = flatten(tuple_lst) 

  #Recreate the original tuples. 
  pair_lst = [(indices[i],indices[len(tuple_lst) + i]) for i in range(len(tuple_lst))] 

  #Transform them to indices into the key
  idx_lst = [5*pair[0] + pair[1] for pair in pair_lst]

  #Decrypt. Transform the resulting list to a string
  plaintext = ''.join([key[idx] for idx in idx_lst])

  return(plaintext)
